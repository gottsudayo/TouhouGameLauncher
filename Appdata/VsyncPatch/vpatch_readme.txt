VsyncPatch

■対応OS
確認済：Windows XP SP2 32bit版
非対応：NT系のAPIを使用しているため、95/98/Meは動作不可能
動作報告有：XP64bit、Vista32bit

■対応ゲーム
東方紅魔郷 ver1.02h
東方妖々夢 ver1.00b
東方永夜抄 ver1.00d
東方花映塚 ver1.50a
東方文花帖 ver1.02a
東方風神録 ver1.00a
黄昏酒場   ver1.00a (web配布版)
東方地霊殿 ver1.00a

■警告
本非公式パッチは、ゲームの内部動作を大幅に変更します
本パッチを当てると不具合がでるかもしれません
実行前にscore.dat等をバックアップすることを推奨します
また、十分に動作確認をした上でご使用ください
特に本パッチを使用した状態でリプレイを保存、公開される方はご注意ください
本パッチ適用時のリプレイに関しては、東方Projectスコアボードに投稿することはできません
リプレイをwebやuploder等で公開する場合は、VsyncPatchを使用していることを明記すると、
トラブルになりにくいかと思います
本パッチは非公式に作成したものです
公式に問い合わせないようにお願いします

■効果
本パッチを使用することにより、CPU使用率が常に100%になる現象を回避できます
紅魔郷の場合、環境によって、58fpsや62fps等で固定されてしまう現象を回避できます
妖々夢の場合、桜点が100万点を超えると表示がおかしくなりますが、これを修正できます
風神録の場合、windowモードで50fpsになったりする現象を回避できます
風神録の場合、確実に垂直同期されるため遅延を感じることがありますが、これも回避できます
リプレイを再生するとき、skipボタンを押下すると高速再生できます
垂直同期を取っても、入力遅延を少なくすることができます
低性能なPCで垂直同期OFFの状態でプレイすると、
弾幕が多く表示される高負荷の場面にて、表示がかくつくことがありますが、
これも緩和することができます
ゲームを60fps以外で、例えば120fpsで変態プレイができます(要高性能PC)

■再配布
ご自由に再配布してくださってかまいません
ただし、zip内のファイルを変更・追加せず
そのままの状態で再配布をお願いします

■ファイル
vpatch.exe
dllを東方.exeにインジェクションするための実行ファイル
東方をプレイしたい時はこの実行ファイルを実行してください
※vpatch.exeは、東方.exeのファイル内容を書き換えるものではありません
※本パッチを適用した状態で東方をプレイしたい時は、
※必ずvpatch.exeを実行する必要があります

vpatch_th??.dll
各東方シリーズ用のパッチ本体
このdllがvpatch.exeによってゲーム上にLoadされ、
メモリ上の実行コードが書き換えられます


■インストール
vpatch.exe、vpatch_th??.dll、vpatch.iniのファイルを
東方シリーズをインストールしたフォルダにコピーしてください
iniファイルは無くても一応動作します

紅魔郷の場合はvpatch.exeとvpatch_th06.dllとvpatch.ini
妖々夢の場合はvpatch.exeとvpatch_th07.dllとvpatch.ini
永夜抄の場合はvpatch.exeとvpatch_th08.dllとvpatch.ini
花映塚の場合はvpatch.exeとvpatch_th09.dllとvpatch.ini
文花帖の場合はvpatch.exeとvpatch_th095.dllとvpatch.ini
風神録の場合はvpatch.exeとvpatch_th10.dllとvpatch.ini
地霊殿の場合はvpatch.exeとvpatch_th11.dllとvpatch.ini
黄昏酒場の場合はvpatch.exeとvpatch_alcostg.dllとvpatch.ini

※パッチの動作不良で、score.dat等がおかしくなる可能性もあるかもしれません
※念のためバックアップをとってからパッチを実行するようにしてください
※また、本ツール上からはゲームのversionをチェックしていないので、
※対応しているかどうか確認してください
※vpatch.exeは、vpatchという名のつくdllを同じフォルダ内で検索し、
※最初に見つかったdllをロードします
※したがって、同じフォルダ内に別のvpatch dllがあると、うまく起動できません
※東方シリーズをインストールしたフォルダには、
※対応しているdllのみを入れるようにしてください

■アンインストール
インストール時にコピーしたexeとdll及びiniファイルを削除してください
また、ゲーム上の「垂直同期を取らない」設定にチェックが入っているので、
垂直同期をONにしてプレイしたい場合は、
custom.exeを起動し「垂直同期を取らない」設定のチェックを消してください

■起動オプション
vpatch.exeを起動する際、コマンドライン引数で、ロードするiniファイルを指定することができます
iniファイルのPathは、相対Pathでも絶対Pathでもファイル名のみでもかまいません
ファイル名だけを書くと、vpatch.exeと同じフォルダにあるiniファイルが読み込まれます
例：
※vpatch.exeの存在するフォルダが C:\Program Files\TH\kouma\ の場合
vpatch.exe "C:\Program Files\TH\vpatch_120fps.ini"
　C:\Program Files\TH\vpatch_120fps.ini が読み込まれます
vpatch.exe ini\vpatch_120fps.ini
　C:\Program Files\TH\kouma\ini\vpatch_120fps.ini が読み込まれます
vpatch.exe vpatch_120fps.ini
　C:\Program Files\TH\kouma\vpatch_120fps.ini が読み込まれます

■注意事項
custom.exe上で
　Windowモード、描画間隔=毎回
上記の設定で動作確認をしました
この設定以外でうまく動作するかどうかはわかりません
※本パッチを起動すると、ゲーム上の「垂直同期を取らない」設定が自動的にONにされます
※描画間隔=毎回、以外にすると、ゲーム速度が倍速化することもあります
※申し訳ないですが、毎回以外は非対応ということでお願いします

■iniファイル
[Window]
AskWindowMode = 0以外を指定するとWindow or FullScreenを選択できるダイアログが起動時に表示されます
enabled = 0以外なら下記のWindow設定を有効にします(Windowモード時にWindowサイズや位置を変更できます)
X = 画面のX座標を指定
Y = 画面のY座標を指定
Width = ゲーム画面の幅を設定(default:640)
Height = 高さを設定(default:480)
TitleBar = 0を指定するとタイトルバーを消してゲーム画面のみにします
AlwaysOnTop = 0以外を指定すると常に手前に表示します

[Option]
Vsync (デフォルト=0)
　0を指定すると垂直同期をせずに、描画を行います

　1を指定すると独自の方法で垂直同期をとり、描画を行います
　Gameの速度(fps)は、リフレッシュレートと同じになります

　2を指定すると、垂直同期を取りつつ、GameFPSに設定されたfpsで描画を行います
　リフレッシュレートが60Hz以外でも60fps(GameFPS)に近いレートで描画が可能ですが、
　均等なレートで画面が更新できないため、弾の移動等が滑らかに描画できない可能性があります
　※CalcFPS=0にしている場合は、fps表示が不安定になることがあります(59fps～61fps辺りをふらつく)
　※CalcFPS=1の場合でも、多少不安定になることがありますが、四捨五入時には60fpsになると思います

　3を指定すると、走査線が画面の中央に来たときに描画を行います
　Gameの速度(fps)は、リフレッシュレートと同じになります
　必ず画面の中央付近でティアリングが起こるようになりますが、
　Vsync=1の時と比べて、画面の下半分の領域の描画遅延が8ms程度少なくなります(60Hz時)
　主に画面下でキャラを操作する人向きです
　※画面上半分は8ms～16ms程度の描画遅延が起こります
　※ちなみにVsync=1の時は、画面上半分は0～8ms程度の描画遅延、画面下半分は8ms～16ms程度の描画遅延が起こります
　※Vsync=0の描画遅延は、描画タイミングが不定のため、描画遅延も不定です

　Vsync=1の垂直同期は、東方本家の垂直同期とは違い、入力遅延はほとんどありません
　裏画面に次のフレームを描画している最中に垂直帰線消去期間(VBlank)を過ぎた場合は、
　同期せずにすぐに描画します
　つまり、この場合はティアリングが発生しますが、遅延せずに描画が可能です
　Vsync=1にする場合は、モニタのリフレッシュレートを60Hzにする必要があります
　PC環境により、ぴったり60.00fpsで描画できない可能性があります
　(59.75fpsだったり60.10fpsだったりします)
　これは走査線の速度がぴったり60.00Hzではないということです(仕様です)

　Vsync=0にして、60.00fpsでGameが動作している時に、
　ティアリングが発生しているLineが、上か下に微妙に少しずつずれていくのが
　目で確認できると思います
　ティアリングが発生しているLineが、全く同じ箇所で起こっているならば、
　走査線の速度はぴったり60.00Hzということです
　ティアリングが発生しているLineが、上に移動していくなら、走査線の速度は
　60.00Hzよりも遅いです
　逆に、下に移動していくなら、60.00Hzよりも速いということです
　60.00Hzぴったりの環境は、ほとんどないと思います

　PC環境によってはリフレッシュレートを60Hzに設定しても、
　実際には75fpsになることもあります　謎です
　OS上のリフレッシュレート設定が60Hzでも、モニタ側の設定
　(モニタ側の周波数を見る方法はモニタのマニュアルをご覧ください)を見ると
　75Hzと表示されているので、実際には75Hzしか設定できない
　ということなのかもしれません
　※液晶モニタを接続すると75fpsになるのかもしれません
　※当方の環境では、CRTモニタを接続すると60fpsになりました
　※(Dualviewの場合は、CRTをプライマリにしないとだめっぽいです)
　※液晶モニタの場合は、Vsync=0でご使用ください
　※VGAデバイスが走査線の読み取りをサポートしていない場合は、
　※Vsync機能は自動的にOFFになります

SleepType (デフォルト=1)
　FPS制御を完璧にするかどうかの設定です
　0の場合は、Sleep復帰後すぐに描画するようにします
　0を指定するとPC環境によってはFPS表示がかなりふらつきますが、CPU負荷はかなり低いです
　1にすると、Sleepする時刻を1ミリ秒少なくし、
　Sleep復帰後、描画時刻を調査して、描画時刻ぴったりに描画するようにします
　-1にすると、Sleepの精度を調査して、高精度の場合はSleepTypeを0にします
　低精度の場合は、SleepTypeを1にします
　※通常は1にしてください
　※どうしても低負荷で動作させる必要がある場合は0を設定してください
　※SleepType=0にした場合は、Vsync=1にする場合、正常にvsyncできない可能性があります

BltPrepareTime (デフォルト=4)
　実際に画面に表示される何ミリ秒前に、
　裏画面に次のフレームを描画し始めるかを指定します
　0～16の数字を指定してください
　数字が大きいほど入力遅延を感じますが、
　大量の弾幕がある高負荷な状態でも滑らかに表示できます
　高速なPCなら4～6程度を、低速なPCなら10程度を指定してください
　描画が滑らかにならない場合は、1ずつ増やしてテストしてください
　入力遅延を感じる場合は、1ずつ減らしてテストしてください
　Vsync=1にする場合は、BltPrepareTimeは0より大きい数値を設定してください
　0にすると必ずティアリングが発生します
　BltPrepareTime=0にすると、裏画面に描画後、ただちに表画面に転送しますが、
　裏画面に描画する時間が弾幕の量によってまちまちなため、
　常に一定の描画間隔で表示できず、結果、かくつきを感じやすくなります
　(特に低性能なPCでより大きなかくつきを感じます)
　※AutoBltPrepareTime=1の場合は、BltPrepareTimeの設定は無視されます
　※BltPrepareTimeの設定を有効にしたい場合は、必ずAutoBltPrepareTime=0にする必要があります
　※BltPrepareTime=-1にした場合は、強制的にAutoBltPrepareTime=1が設定されます

AutoBltPrepareTime (デフォルト=1)
　0を指定した場合は、何もしません
　1を指定すると、描画完了時間の統計を取り、最適なBltPrepareTimeを自動でセットします
　AutoBltPrepareTimeを1にすると、BltPrepareTimeの設定は無視されます
　※BltPrepareTime=-1にした場合は、AutoBltPrepareTimeの設定は無視されます

GameFPS (デフォルト=60)
　ゲームするFPSを指定します
　通常は60を指定してください
　60未満の数値は指定できません
　※Vsync=1の場合は、モニタのリフレッシュレートと同じFPSになり、
　※GameFPSは無視されます

ReplaySkipFPS (デフォルト=240)
　リプレイを再生しているときにskipボタンを押下すると、
　ReplaySkipFPSのレートで再生できます
　このオプションは、描画する速度を変更するだけです
　Direct3D命令の呼び出しを省略して内部変数だけを変更してフレームを飛ばす、
　というわけではありません
　高いFPSを設定しても、低性能なPC環境では、そのレートまで出せない可能性があります
　対応ゲーム：紅魔郷、妖々夢、永夜抄、花映塚

ReplaySlowFPS (デフォルト=30)
　リプレイを再生しているときにslowボタンを押下すると、
　ReplaySlowFPSのレートで再生できます
　変態さんのリプレイを見る時に役に立つかもしれません
　対応ゲーム：紅魔郷、妖々夢、永夜抄、花映塚、風神録、黄昏酒場

CalcFPS (デフォルト=1)
　0以外を指定すると、ゲーム上で表示されるFPS表示を、独自方法で算出するようにします
　妖々夢のFPS表示がおかしい場合は、1を指定すると改善されます
　GameFPSを60以外にしている場合は、1を指定しないとFPS表示が変になるかもしれません
　かなり正確なFPSが表示できると思われますので、CalcFPS=1を推奨します
　Vsync=1にしている場合は、ぴったり60.00FPSにはならないと思われます

AlwaysBlt (デフォルト=0)
　custom.exeの"ウィンドウスタイル"が"ウィンドウ"用の設定です(Windowモード用の設定です)
　1にすると、ゲームWindowが非アクティブでも、常に描画を行うようにします
　これを1にすると、ゲームWindowのフォーカスをはずした場合に、
　キー入力が入りっぱなしになる現象等を修正するために、
　Game内の入力処理コードが修正されます
　keyboard入力は、ゲームWindowがアクティブの時のみ反応します
　custom.exeの「入力にDirectInputを使用しない」の項目は、チェックしてもしなくても問題ありません
　対応ゲーム：紅魔郷、妖々夢

BugFixCherry (デフォルト=1)
　これを0以外にすると、桜点表示バグを修正します
　桜点Nowが100万を超えた時に表示がおかしくなるのが気になる場合は1を指定してください
　対応ゲーム：妖々夢

BugFixTh10Power3 (デフォルト=0)
　これを0以外にすると、風神録の貫通装備魔理沙のパワー3状態での高速移動時のショットが
　異常な攻撃力になるバグを修正します
　バグ修正とは言っても、ショットの威力が122の場合、12に補正するという処理を行うだけです
　魔理沙B、P3、高速状態、右のメインショットの威力を12に補正する処理ではないので、
　もしかすると、他へ影響があるかもしれません
　十分注意してご使用ください
　BugFixTh10Power3=1にして保存したリプレイは、
　リプレイを再生する側でもBugFixTh10Power3=1にして再生する必要があります
　pingval氏のご協力により、power3バグ修正を行うことができました
　ありがとうございました

ProcessPriority (デフォルト=0)
　※この項目は初期iniには存在しません　手動で追加してください
　ゲームのプロセスの優先度を指定します
　値：-2:低  -1:通常以下  0:通常  1:通常以上  2:高

ProcessAffinityMask (デフォルト=0)
　※この項目は初期iniには存在しません　手動で追加してください
　どのCPUでプロセスを実行するかを制御できます
　1:CPU0でのみ実行
　2:CPU1でのみ実行
　3:CPU0とCPU1で実行
　各ビットはプロセスのスレッドを実行できるプロセッサを表します
　ProcessAffinityMaskは10進数で指定してください

LockBackBuffer (デフォルト=0)
　※この項目は初期iniには存在しません　手動で追加してください
　vsyncが正常にできない場合に、1にしてください
　1にすると、Present直前にバックバッファをロックし、すべてのDirect3D描画命令の完了を待機します
　通常は1にする必要はありません
　0でティアリングが発生する環境では、1にすることで正常にvsyncが行えるようになるかもしれません
　副作用で、負荷のかかる場面でfpsが極端に落ちる可能性があります(メッセージスキップ時等)


★これより下に書いてある文章は、一般の方には必要のない情報です
★パッチがどのように動作しているのか、
★また、WindowsAPIの仕様・動作について書いてあります
★興味のない方は読み飛ばしてくださってかまいません



■技術情報
本パッチが内部でどのような動作をするかを書いておきます
すべてのパッチは下記の様に動作します
・東方本家のtimeBeginPeriod()とtimeEndPeriod()の呼び出しをすべて無効化します
・アプリ起動時にtimeBeginPeriod(1)を実行し、アプリ終了時にtimeEndPeriod(1)を実行するようにします
・IDirect3D::CreateDevice()を呼び出す際の引数、
　D3DPRESENT_PARAMETERS内部のD3DSWAPEFFECTを、D3DSWAPEFFECT_DISCARDに強制設定します
　また、DirectX9の場合、PresentationIntervalメンバ変数にD3DPRESENT_INTERVAL_IMMEDIATEを強制設定します
・本家の処理では、描画開始時刻未満の場合にSleep(0)が呼び出され、WindowMsg処理へ何度も飛びますが、
　本パッチでは、描画開始時刻判定処理をHookし、描画開始時刻まではSetWaitableTimer()を使い、待機するようにします
　WindowMsg処理は1フレームに1回しか行わないようにします
・裏画面から表画面への転送処理(IDirect3DDevice::Present())をHookし、vsync待ち等の処理を行うようにします
・処理の流れは下記の通りです
　WindowMsg処理 → 描画開始時刻までWait → 裏画面へ描画 → 表画面へ転送(Present処理) → WindowMsg処理
・現在のFPSを表示するためのfps計算は、Present処理をした時刻を元に計算します(本家では裏画面描画中の時刻が元)
　Present処理をした時刻というのは、Presentを呼び出す直前の時刻です
　Present後の時刻を元にfpsを算出すると、Present自体の処理時間が一定では無い場合にfpsが異常に乱れる場合があります
　(FrapsやDxtory等の外部ソフトにより、Presentがhookされる場合等)
　上記の理由により、fps計算には、Presentを呼び出す直前の時刻を使用します
　ただし、ハードウェア側のvsyncをonにする場合、DirectX9＆windowモード時は、Presentをcallすると内部でsleepされるため
　Present後の時刻を元にfpsを算出する必要があるかもしれません
・妖々夢でFPS表示が乱れるのは、
　QueryPerformanceCounter()で得た値の下位32bitの値のみを使って演算するために起こります
　特にQueryPerformanceCounter()等で返される値が異常に大きい環境でFPS表示が乱れると思われます
　デュアルコア環境の場合、QueryPerformanceCounter()で返される値がRDTSC(Time Stamp Counter)の値になるため、
　おかしくなるものと思われます
　デュアルコアパッチを当てると、妖々夢でのFPS表示は直りますが、これは
　QueryPerformanceFrequency()で返される値が、Power Management Timerに変更されるためのようです
　このTSCとPMタイマの精度の差は、大きい環境の場合は1000倍くらい違います
　※上記事項は、PC環境によりますので、全ての環境には当てはまりません
　※http://support.microsoft.com/default.aspx?scid=kb;ja;327809
　※妖々夢のfps表示の乱れは、boot.iniに/usepmtimerを指定するだけで修正できる環境が多いと思います
・風神録でWindowモード時、なぜか50fps以下になることについて…
　PresentationIntervalメンバ変数にD3DPRESENT_INTERVAL_DEFAULTが指定されているため、
　垂直同期が取られるようになります
　この垂直同期処理はDirect3D内部でSleep()を使って実装されています
　風神録ではtimeBeginPeriod()が呼び出されていないため、Sleepの精度が10～15ms程度になってしまい
　うまく垂直同期処理ができず、飛び飛びになってしまうため、60fpsが維持できなくなってしまうのだと思われます
・本パッチ上の垂直同期処理には、IDirect3DDevice::GetRasterStatus()を使用していますが、
　InVBlankメンバ変数を見てVBlankを判断しているのではなく、
　ScanLineメンバ変数を見て、次のVBlankの時刻を計算し、
　その時刻まで待ってからPresent()をするようにしています
　環境によっては、InVBlankはよく読み飛ばされる気がします

■timeBeginPeriod
timeBeginPeriod()を呼び出すと、Sleep()やWaitForSingleObject()等の精度が変わります
timeGetTime()やSleep()の精度だけしか変わらないと思ったら、大間違いのようです
SetWaitableTimer()＆WaitForSingleObject()を使い、100ナノ秒単位の精度で
待機したい場合は、必ずtimeBeginPeriod(1)を呼ぶ必要があるようです
※timeBeginPeriod(1)を呼ばない状態でWaitForSingleObject()の精度が1ms以下の環境は
※おそらくWMP等のアプリがすでにtimeBeginPeriod(1)を呼んでいるために
※精度が高くなっていると思われます

MSDNライブラリのtimeBeginPeriod()の解説に
　タイマサービスの使用直前にこの関数を呼び出し、
　タイマサービスの使用終了後ただちに timeEndPeriod 関数を呼び出してください。
と書いてあります
これを鵜呑みにしてこのまま実装してしまうと、
timeGetTime()を呼び出すたびにtimeBeginPeriod(),timeEndPeriod()等を
呼ぶ必要があるように聞こえますが…
大嘘です　MSDNの罠です　引っかかっちゃだめです　＞ZUN氏
timeBeginPeriod()を呼び出してもすぐには精度が変わらなく、
若干の間を必要とするという情報もあります
timeBeginPeriod()はアプリ起動時に、
timeEndPeriod()はアプリ終了時に呼び出すのが良いらしいです

上記はWindowsXPや2000の話です
Vistaの場合はAvSetMmThreadCharacteristicsという関数があります
詳細はgoogleやMSDNライブラリ等で調べてください
timeBeginPeriodと同じ効果があります


■SetWaitableTimer＆WaitForSingleObjectの精度について
1.4GHzのシングルコアCPU搭載PC環境の場合において、1ミリ秒未満の精度を確認しました
おそらくこのような環境ではSleepType=0でも全く問題ないと思われます
2.6GHzのデュアルコアCPU搭載PC環境の場合、精度が1ミリ秒単位になりました
1.5ミリ秒を指定しても2ミリ秒程度Sleepしてしまいます
何が原因でこうなるのかはわかりませんが、
SetWaitableTimer＆WaitForSingleObjectの精度は、
環境によってバラバラで信用できないみたいです

■double型の精度について
QueryPerformanceCounterで得た値をdoubleに変換して、
doubleでfps制御及びfps表示のための計算を行うと、fpsがふらつくようになります
doubleではなくて、64bitの整数型(LONGLONG)で演算すると
全くふらつかなくなりました
色々実験をしたわけではありませんが、double型の精度が悪いとしか思えません
(あるいはdoubleの精度を超える演算をしている可能性があるかも…)
(演算方法が悪いということはたぶん無いと思います。LONGLONGの場合と同じ演算方法でfpsがふらつくので)
時刻情報はできるだけ、QueryPerformanceCounterで得た値を
そのままLONGLONGで保持した方が良いかと思います

x86CPUの場合、ローカル変数を使用して演算する場合は、
float,doubleの型に関係なくfpuレジスタで80bitの精度で演算されますが、
float,double型はメモリに保存するだけで値が丸められ、精度が落ちるようです
特にグローバル変数・メンバ変数で保存・アクセスする場合に問題がでるようです
「小数の計算精度」でググると、良い文献が見つかります

IDirect3D::CreateDevice() をcallする際、
BehaviorFlagsに、D3DCREATE_FPU_PRESERVEを指定しないと
浮動小数の計算精度が単精度に設定されます
Game内でdouble型の変数を使用する場合は、必ずD3DCREATE_FPU_PRESERVEを指定する必要があります
※単精度に設定されるのはメインスレッド(CreateDeviceをcallしたスレッド)だけです
※それ以外のスレッドでは規定の倍精度で演算できます
※(別スレッドからDirect3D関連の関数をcallした場合については未確認)


■紅魔郷・妖々夢・永夜抄の入力遅延について
紅魔郷と妖々夢は、フレームレート制御を行っている場所が悪いために、
常に1フレームの描画遅延があります
処理の流れは以下の通りです
WindowMsg処理 → IDirect3DDevice8::BeginScene() → リストに登録された描画情報を裏画面に描画 →
IDirect3DDevice8::EndScene() → 現在のkey入力情報を取得 → キャラ移動等の処理を行い、描画情報をリストに登録 →
次のフレーム描画時刻まで待つ(フレームレート制御) → IDirect3DDevice8::Present() → WindowMsg処理

妖々夢は、上記の描画遅延に追加で、さらに1フレームの遅延があります
処理の流れは以下の通りです (key入力処理とキャラ移動処理のみを表記)
　　現在のkey入力情報を取得し、変数Aに代入 → 変数Bを参照して、キャラ移動の処理を行う → 変数Bに変数Aを代入
※つまり、1フレーム前の入力を見ているということです
※妖々夢は描画遅延と入力遅延を合わせて2フレームの遅延があります

永夜抄は、妖々夢と同じ入力遅延が1フレームあります
フレームレート制御は正常なため、描画遅延はありません

上記の遅延を修正したことにより、大幅に描画完了待ち時間が少なくなります
今までは60fpsを維持していた場合でも、負荷のかかる場面でfpsが落ちる可能性があります
特に低性能なPCで、この現象が顕在化する可能性が高いです


■地霊殿について
修正点は、"自動"と"高速"のみです
また、描画間隔="毎回"の時のみvpatchが動作します
ini項目のCalcFPSを1にした場合は、2重に四捨五入している部分も修正されます
　(実fpsが60.01fpsの時に、60.1fpsと表示されるのを、60.0fpsに修正)
ini項目のVsyncの設定は無視されます
ini項目のReplaySkipFPSの設定は無視されます
ini項目のReplaySlowFPSの設定は無視されます
地霊殿のcustom.exeにて、入力のレイテンシを自動にするとVsync=1、
入力のレイテンシを高速にするとVsync=0としてGameが動作します
iniでVsync=2にしている場合は、入力のレイテンシを自動にするとVsync=2として動作します
入力のレイテンシ：安定と通常については、元々の動作のままです


■ソースコードの公開について
vpatch rev4で、かなり良い感じのコードが作成できたと思っているのですが
この技術が公開できないのは、少々もったいない気がします
Game制作者の方は、Game本体の部分(グラフィックや音楽等)に注力してらっしゃるはずですから
fps制御や入力遅延等の細かい部分には、ほとんど気を使えないと思うのです
せめて、vpatchのfps制御(vsync制御)のソースだけでも公開できればと思うのですが…


■version履歴
2008/04/01 rev1
　正式公開

2008/04/11 rev2
　・GetRasterStatusで得たScanLine値が、モニタの高さの値を超えてしまう
　　仕様外の動作をする環境に対応  ツール総合スレ2 >>208氏thx
　　→Vsync=1にすると不定期にハングアップする現象が直るかも
　・走査線の読み取りをサポートしているかどうかの調査の方法を変更
　　ScanLine値が変動しているかを検査します
　・走査線の速度を計測する方法を変更
　　→Vsync=1にするとGame起動時にCPU100%で固まる現象が直るかも
　　→と思ったけど、CPU100%で固まる現象は仕様外の値を吐くGetRasterStatusがらみの問題なのかも
　・ini項目追加：AskWindowMode(風神録・黄昏酒場は元々ある機能なため非対応)
　　ツール総合スレ2 >>208氏thx
　・技術情報追加：double型の精度について
　・風神録・黄昏酒場のReplaySlowFPS対応
　　文花帖は、リプレイフラグが見つからないため未対応
　・紅魔郷のFPS制御を少し変更
　・描画間隔を毎回以外にすると倍速化する件ですが、Gameによっては
　　vsync=1にすると倍速化するようです(vsync=0でも倍速化するGameもあり)
　　描画間隔:毎回、以外の対応は少し難しいです　申し訳ないですが仕様ということでお願いします

2008/04/12 rev3
　・紅魔郷：フルスクリーン時、デバイスのvsyncがonになっていたのをoffに修正
　　また、フルスクリーン専用のFPS制御処理(強制60frame等)をskipするように変更
　　→フルスク時、おそらく入力遅延が発生していたと思います　この修正で入力遅延が少なくなります
　　→フルスク時、リプレイ高速再生ができなかったのが直ります
　　→フルスク時、高FPSでGameができなかったのが直ります

2009/03/01 rev4
　・紅魔郷：1フレームの入力遅延を解消
　・妖々夢：2フレームの入力遅延を解消
　・永夜抄：1フレームの入力遅延を解消
　・紅魔郷＆妖々夢：AlwaysBlt=1の時の挙動を変更
　　→ゲームWindowのフォーカスをはずした場合に、
　　→キー入力が入りっぱなしになる現象等を修正するために
　　→入力処理コードを修正するようにしました
　　→Game起動時にキーが入りっぱなしになる現象も修正できたと思います
　　→この変更により、iniのNoKeyboardの項目は必要なくなりました
　・地霊殿に対応
　・ini項目削除：NoKeyboard
　・ini項目削除：BltFineTuneTime
　・ini項目追加：AutoBltPrepareTime
　・ini項目追加：SleepType
　・ini項目追加：LockBackBuffer
　・ini項目更新：Vsync
　・技術情報追加：紅魔郷・妖々夢・永夜抄の入力遅延について
　・技術情報追加：地霊殿について
　・精度が維持できるように各種計算式・アルゴリズムを変更
　・走査線の速度を計測する方法を変更
　　→走査線を読み飛ばす可能性を最小限に減らしました
　　→速度計測に失敗した場合にFPSがおかしくなっていたのが直ります
　・vsyncの方法を変更
　　→VBlank時刻を正確に算出できるようにしました
　　→リフレッシュレートを参照せずに、走査線のみを見て次のVBlank時刻を算出します
　　→リフレッシュレートと走査線の速度が合っていない環境で、
　　→FPSが不安定だったのが直ります

■作者
◆swmpLV/75E
